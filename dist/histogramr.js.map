{"version":3,"sources":["lib/Maybe.js","lib/csv.js","index.js"],"names":[],"mappings":";;;;AAAA;;AAAA;AACI;AAAY;AAAe;AAC/B;AAIA;AAAiC;AAA2C;AAAyC;AAA2B;AAAwD;AAAgC;AAA2B;AAA0B;MAA6D;AAAA;AAAE;AAA2D;AAAgB;AAAmD;AAAmB;AAA0C;IAAsB;EAAG;AAEhjB;AAAkD;AAA0C;IAA0D;AAAA;AAAE;AAGpJ;AACI;AAEA;IACJ;AAAA;AAGI;AACA;AAEI;MACJ;AAAA;AAEA;AACA;AAEI;MACJ;AAAA;AAEA;AACA;AAEI;MACJ;AAAA;AAEA;AACA;AAEI;MACJ;AAAA;AAGJ;EACJ;AAEA;AACI;EACJ;AAEA;AAlDA;AAAiG;AAkD1E;AClDvB;;AAAA;AACI;AAAY;AAAe;AAC/B;AAIA;AAAqG;EAAmB;AAAqB;EAA8H;AAO3Q;AACI;AACA;AACI;AAEJ;AAA8D;;AAA2B;AAA4B;AAEhF;OAAiB;AAAoB;;AAAiD;AAAyB;EAGxJ;AAAA;AAUI;AACI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGJ;AACI;IACJ;AAAA;AAEI;IACJ;AAAA;AAII;AACA;AACA;AAEI;AACI;AACI;AACA;UACJ;AAAA;AACJ;AAEA;MACJ;AAAA;AAGA;AACA;AACI;AACA;AACA;AACI;QACJ;AAAA;MAEJ;AAAA;IAEJ;AAAA;EAGJ;AAAA;AAlFA;AAAiG;AAoF1E;ACpFvB;;AAAA;AACI;AAAY;AAAe;AAC/B;AAGA;AAEA;AAEA;AAEA;AAEA;AAEA;AAAuC;EAAuD;AAAA;AAE3D;AAA0B;AAAgB;AAAiD;MAAkB;AAAA;IAAe;AAAS;IAAwB;AAAA;AAAE;AAI9L;AACA;AACI;AAAkC;AAAoB;AAClD;MACJ;AAAA;AAGA;AACA;IACJ;EACJ;AAEA;AAEI;AAEA;AAEI;AAEI;MACJ;IACJ;AAEA;EACJ;AAAA;AAII;AAEA;AAEI;AAAuB;AAAW;AAIlC;AAAiB;AAAuC;IAG5D;EACJ;AAAA;AAII;AAEA;AAEI;AAEA;AAEA;IACJ;EACJ;AACA;AAEA;AAEI;AAEA;EACJ;AAAA;AAII;AAEA;EACJ;AAAA;AAII;AAEA;AAEI;IACJ;AAEA;EACJ;AAAA;AAII;AAEA;AAEI;AAEA;AAEA;AAEI;AACA;AACA;AACA;MACJ;AAEA;IACJ;AAEA;AAEA;EACJ;AAAA;AAII;AAEA;AACI;AACA;AACA;AACA;AAEI;MACJ;AACA;AAEI;MACJ;AAAA;EAER;AAAA;AApJA;AAAwG;AAsJ3E","file":"histogramr.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Maybe = function () {\n    function Maybe(x) {\n        _classCallCheck(this, Maybe);\n\n        this.__value = x;\n    }\n\n    _createClass(Maybe, [{\n        key: \"map\",\n        value: function map(f) {\n\n            return this.isNothing() ? Maybe.of(null) : Maybe.of(f(this.__value));\n        }\n    }, {\n        key: \"isNothing\",\n        value: function isNothing() {\n\n            return this.__value === null || this.__value === undefined;\n        }\n    }, {\n        key: \"join\",\n        value: function join() {\n\n            return this.isNothing() ? Maybe.of(null) : this.__value;\n        }\n    }, {\n        key: \"emit\",\n        value: function emit() {\n\n            return this.__value;\n        }\n    }]);\n\n    return Maybe;\n}();\n\nMaybe.of = function (x) {\n    return new Maybe(x);\n};\n\nexports.default = Maybe;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n* Converts a value to a string appropriate for entry into a CSV table.  E.g., a string value will be surrounded by quotes.\n* @param {string|number|object} theValue\n* @param {string} sDelimiter The string delimiter.  Defaults to a double quote (\") if omitted.\n*/\nfunction toCsvValue(theValue, sDelimiter) {\n    var t = typeof theValue === \"undefined\" ? \"undefined\" : _typeof(theValue);\n    var output = void 0,\n        stringDelimiter = void 0;\n\n    if (typeof sDelimiter === \"undefined\" || sDelimiter === null) stringDelimiter = '\"';else stringDelimiter = sDelimiter;\n\n    if (t === \"undefined\" || t === null) output = '';else if (t === 'string') output = sDelimiter + theValue + sDelimiter;else output = String(theValue);\n\n    return output;\n}\n\n/**\n* Converts an array of objects (with identical schemas) into a CSV table.\n* @param {Array} objArray An array of objects.  Each object in the array must have the same property list.\n* @param {string} sDelimiter The string delimiter.  Defaults to a double quote (\") if omitted.\n* @param {string} cDelimiter The column delimiter.  Defaults to a comma (,) if omitted.\n* @return {string} The CSV equivalent of objArray.\n*/\nfunction toCsv(objArray, sDelimiter, cDelimiter) {\n    var i = void 0,\n        l = void 0,\n        names = [],\n        name = void 0,\n        value = void 0,\n        obj = void 0,\n        row = void 0,\n        output = \"\",\n        n = void 0,\n        nl = void 0;\n\n    // Initialize default parameters.\n    if (typeof sDelimiter === \"undefined\" || sDelimiter === null) {\n        sDelimiter = '\"';\n    }\n    if (typeof cDelimiter === \"undefined\" || cDelimiter === null) {\n        cDelimiter = \",\";\n    }\n\n    for (i = 0, l = objArray.length; i < l; i += 1) {\n        // Get the names of the properties.\n        obj = objArray[i];\n        row = \"\";\n        if (i === 0) {\n            // Loop through the names\n            for (name in obj) {\n                if (obj.hasOwnProperty(name)) {\n                    names.push(name);\n                    row += [sDelimiter, name, sDelimiter, cDelimiter].join(\"\");\n                }\n            }\n            row = row.substring(0, row.length - 1);\n            output += row;\n        }\n\n        output += \"\\n\";\n        row = \"\";\n        for (n = 0, nl = names.length; n < nl; n += 1) {\n            name = names[n];\n            value = obj[name];\n            if (n > 0) {\n                row += \",\";\n            }\n            row += toCsvValue(value, '\"');\n        }\n        output += row;\n    }\n\n    return output;\n}\n\nexports.default = toCsv;","'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = undefined;\n\nvar _Maybe = require('./lib/Maybe');\n\nvar _Maybe2 = _interopRequireDefault(_Maybe);\n\nvar _csv = require('./lib/csv');\n\nvar _csv2 = _interopRequireDefault(_csv);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nvar memoize = function memoize(fn) {\n\n    var cache = {};\n    return function () {\n        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n        }\n\n        var stringifiedArgs = JSON.stringify(args);\n        var result = cache[stringifiedArgs] = cache[stringifiedArgs] || fn.apply(undefined, args);\n        return result;\n    };\n};\n\nfunction parseChartColumns(arr) {\n\n    var obj = {};\n\n    Object.keys(monthOfTheYear()).forEach(function (key) {\n\n        obj[key] = monthOfTheYear()[key].map(function (val) {\n\n            return Number(arr[val]);\n        });\n    });\n\n    return obj;\n}\n\nfunction getTaxaList(arr) {\n\n    var startLine = 15;\n\n    return arr.reduce(function (prev, current, index) {\n\n        if (index < startLine) return prev;\n\n        var tabs = current.split(/\\t/);\n\n        if (tabs.length) prev[tabs[0]] = parseChartColumns(tabs);\n\n        return prev;\n    }, {});\n}\n\nvar _monthOfTheYear = function _monthOfTheYear() {\n\n    var months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'Novermber', 'December'];\n\n    return months.reduce(function (prev, current, index) {\n\n        var oneIndex = (index + 1) * 4;\n\n        prev[current] = [oneIndex - 3, oneIndex - 2, oneIndex - 1, oneIndex];\n\n        return prev;\n    }, {});\n};\nvar monthOfTheYear = memoize(_monthOfTheYear);\n\nfunction getTaxa(arr) {\n\n    var position = 10;\n\n    return Number(arr[position].split(/\\t/)[1]);\n}\n\nfunction getSampleSize(arr) {\n\n    var position = 13;\n\n    return parseChartColumns(arr[position].split(/\\t/).slice(1));\n}\n\nfunction sampleToCsv(val) {\n\n    var sample = [\"Sample Size\"];\n\n    Object.keys(val).forEach(function (key) {\n\n        sample.push.apply(sample, _toConsumableArray(val[key]));\n    });\n\n    return (0, _csv2.default)([sample]).split(/\\n/).slice(1);\n}\n\nfunction taxaToCsv(val) {\n\n    var arr = [];\n\n    Object.keys(val).forEach(function (key) {\n\n        var obj = {};\n\n        obj.name = key;\n\n        Object.keys(val[key]).forEach(function (val2) {\n\n            obj[val2 + '_1'] = val[key][val2][0];\n            obj[val2 + '_2'] = val[key][val2][1];\n            obj[val2 + '_3'] = val[key][val2][2];\n            obj[val2 + '_4'] = val[key][val2][3];\n        });\n\n        arr.push(obj);\n    });\n\n    arr.pop();\n\n    return (0, _csv2.default)(arr);\n}\n\nfunction processFile(str) {\n\n    var lines = str.split(/\\n/);\n\n    return _Maybe2.default.of({\n        sampleSize: getSampleSize(lines),\n        taxaCount: getTaxa(lines),\n        taxaList: getTaxaList(lines),\n        get taxaCsv() {\n\n            return taxaToCsv(this.taxaList);\n        },\n        get allCsv() {\n\n            return sampleToCsv(this.sampleSize) + '\\n' + this.taxaCsv;\n        }\n    });\n}\n\nexports.default = processFile;"]}